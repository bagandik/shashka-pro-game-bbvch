<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Qiyin Shashka - AI ga qarshi Inson</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Custom styles */
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 640px;
            height: auto;
            aspect-ratio: 1/1;
            border: 4px solid #8B4513;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .dark-square {
            background-color: #8B4513; /* Dark brown */
        }
        
        .light-square {
            background-color: #F5DEB3; /* Wheat */
        }
        
        .piece {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .piece:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        
        .piece.selected {
            transform: scale(1.1);
            box-shadow: 0 0 0 4px #FFD700, 0 0 20px #FFD700;
            z-index: 10;
        }
        
        .piece.human {
            background: radial-gradient(circle at 30% 30%, #FF0000, #8B0000);
        }
        
        .piece.ai {
            background: radial-gradient(circle at 30% 30%, #0000FF, #00008B);
        }
        
        .piece.king::after {
            content: "♔";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: bold;
        }
        
        .valid-move {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: rgba(0, 255, 0, 0.5);
            pointer-events: none;
            z-index: 5;
        }
        
        .capture-move {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px dashed rgba(255, 0, 0, 0.7);
            background-color: rgba(255, 0, 0, 0.2);
            pointer-events: none;
            z-index: 5;
        }
        
        .game-over {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-900 to-gray-800 text-white min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold mb-4 text-yellow-400">
                <i class="fas fa-chess-board mr-4"></i>Super Qiyin Shashka - AI ga qarshi Inson
            </h1>
            <p class="text-lg md:text-xl text-gray-300 max-w-3xl mx-auto">
                Yengib bo'lmaydigan AI ga qarshi o'yna. Eng yaxshi o'yinchilar ham 4-5 daqiqada yutqazadi. Sen chidaysanmi?
            </p>
        </header>

        <div class="flex flex-col items-center gap-8">
            <!-- Game Board -->
            <div class="flex flex-col items-center w-full">
                <div id="board" class="board mb-6 mx-auto"></div>
                
                <div class="flex flex-wrap justify-center gap-4 mb-6">
                    <button id="new-game" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-300">
                        <i class="fas fa-play mr-2"></i>Yangi o'yin
                    </button>
                    <button id="undo-move" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-300">
                        <i class="fas fa-undo mr-2"></i>Orqaga qaytarish
                    </button>
                    <button id="hint" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-300">
                        <i class="fas fa-lightbulb mr-2"></i>Maslahat
                    </button>
                </div>
            </div>

            <!-- Game Info Panel -->
            <div class="bg-gray-800 rounded-xl p-6 shadow-2xl w-full max-w-lg">
                <div class="mb-8">
                    <h2 class="text-2xl font-bold mb-4 text-yellow-300">
                        <i class="fas fa-gamepad mr-2"></i>O'yin holati
                    </h2>
                    
                    <div class="grid grid-cols-2 gap-4 mb-6">
                        <div class="bg-gray-900 p-4 rounded-lg text-center">
                            <div class="text-sm text-gray-400 mb-1">Inson</div>
                            <div id="human-score" class="text-3xl font-bold text-red-400">12</div>
                            <div class="flex justify-center mt-2">
                                <div class="piece human w-6 h-6 mr-1"></div>
                                <div class="piece human king w-6 h-6"></div>
                            </div>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg text-center">
                            <div class="text-sm text-gray-400 mb-1">AI</div>
                            <div id="ai-score" class="text-3xl font-bold text-blue-400">12</div>
                            <div class="flex justify-center mt-2">
                                <div class="piece ai w-6 h-6 mr-1"></div>
                                <div class="piece ai king w-6 h-6"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="game-status" class="bg-blue-900 p-4 rounded-lg text-center text-xl font-bold">
                        Inson navbati
                    </div>
                </div>
                
                <div class="mb-6">
                    <h3 class="text-xl font-bold mb-3 text-yellow-300">
                        <i class="fas fa-robot mr-2"></i>AI qiyinlik darajasi
                    </h3>
                    <div class="bg-gray-900 p-4 rounded-lg">
                        <div class="text-lg font-semibold text-red-400 mb-2">MUMKIN EMAS</div>
                        <div class="text-sm text-gray-300">
                            Minimax algoritmi bilan Alpha-Beta pruning (chuqurlik 6). Yengib bo'lmaydi — 4 daqiqadan kamroq vaqt ichida yutqazasiz!
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-bold mb-3 text-yellow-300">
                        <i class="fas fa-info-circle mr-2"></i>O'yin qoidalari
                    </h3>
                    <ul class="bg-gray-900 p-4 rounded-lg text-sm space-y-2">
                        <li><i class="fas fa-arrow-right text-green-400 mr-2"></i>Inson puli: <span class="text-red-400">Qizil</span></li>
                        <li><i class="fas fa-arrow-right text-green-400 mr-2"></i>AI puli: <span class="text-blue-400">Ko'k</span></li>
                        <li><i class="fas fa-arrow-right text-green-400 mr-2"></i>Diagonal oldinga yurish</li>
                        <li><i class="fas fa-arrow-right text-green-400 mr-2"></i>Raqib pulini sakrab olish (urib olish)</li>
                        <li><i class="fas fa-arrow-right text-green-400 mr-2"></i>Qirol orqaga ham yurishi mumkin</li>
                        <li><i class="fas fa-exclamation-triangle text-red-400 mr-2"></i><span class="text-red-300">AI juda kuchli — ehtimol yutqazasiz!</span></li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Moves History -->
        <div class="mt-12 max-w-4xl mx-auto">
            <h2 class="text-2xl font-bold mb-4 text-yellow-300">
                <i class="fas fa-history mr-2"></i>Yurishlar tarixi
            </h2>
            <div id="moves-history" class="bg-gray-800 rounded-xl p-4 max-h-60 overflow-y-auto">
                <div class="text-gray-400 text-center py-4">Hozircha yurish yo'q. Birinchi yurishni qiling!</div>
            </div>
        </div>
    </div>

    <script>
        // Game variables
        let board = [];
        let selectedPiece = null;
        let validMoves = [];
        let currentPlayer = 'human'; // 'human' or 'ai'
        let gameOver = false;
        let moveHistory = [];
        let aiThinking = false;
        let boardHistory = [];

        // Initialize the game
        function initGame() {
            createBoard();
            setupPieces();
            renderBoard();
            updateGameInfo();
            
            // AI 80% hollarda birinchi yuradi (qiyinroq qilish uchun)
            if (Math.random() > 0.2) {
                setTimeout(() => {
                    currentPlayer = 'ai';
                    updateGameInfo();
                    makeAIMove();
                }, 1000);
            }
        }

        // Create the board structure
        function createBoard() {
            board = [];
            for (let row = 0; row < 8; row++) {
                board[row] = [];
                for (let col = 0; col < 8; col++) {
                    const isDark = (row + col) % 2 === 1;
                    board[row][col] = {
                        row,
                        col,
                        isDark,
                        piece: null
                    };
                }
            }
        }

        // Setup initial pieces
        function setupPieces() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    board[row][col].piece = null;
                }
            }
            
            // Inson puli (qizil) yuqorida (0-2 qatorlar)
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col].isDark) {
                        board[row][col].piece = {
                            type: 'human',
                            isKing: false,
                            row,
                            col
                        };
                    }
                }
            }
            
            // AI puli (ko'k) pastda (5-7 qatorlar)
            for (let row = 5; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col].isDark) {
                        board[row][col].piece = {
                            type: 'ai',
                            isKing: false,
                            row,
                            col
                        };
                    }
                }
            }
            
            saveBoardState();
        }

        // Render the board
        function renderBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = board[row][col];
                    const squareElement = document.createElement('div');
                    squareElement.className = `square ${square.isDark ? 'dark-square' : 'light-square'}`;
                    squareElement.dataset.row = row;
                    squareElement.dataset.col = col;
                    
                    squareElement.addEventListener('click', () => handleSquareClick(row, col));
                    
                    if (square.piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `piece ${square.piece.type} ${square.piece.isKing ? 'king' : ''}`;
                        pieceElement.dataset.row = row;
                        pieceElement.dataset.col = col;
                        
                        if (square.piece.type === 'human' && currentPlayer === 'human' && !gameOver) {
                            pieceElement.addEventListener('click', (e) => {
                                e.stopPropagation();
                                handlePieceClick(row, col);
                            });
                        }
                        
                        squareElement.appendChild(pieceElement);
                    }
                    
                    const move = validMoves.find(m => m.toRow === row && m.toCol === col);
                    if (move) {
                        const moveIndicator = document.createElement('div');
                        moveIndicator.className = move.captured ? 'capture-move' : 'valid-move';
                        squareElement.appendChild(moveIndicator);
                    }
                    
                    boardElement.appendChild(squareElement);
                }
            }
        }

        // Handle piece selection
        function handlePieceClick(row, col) {
            if (currentPlayer !== 'human' || gameOver || aiThinking) return;
            
            const piece = board[row][col].piece;
            if (!piece || piece.type !== 'human') return;
            
            if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                selectedPiece = null;
                validMoves = [];
            } else {
                selectedPiece = { row, col };
                validMoves = getValidMoves(row, col);
            }
            
            renderBoard();
            
            if (selectedPiece) {
                const pieceElement = document.querySelector(`.piece[data-row="${row}"][data-col="${col}"]`);
                if (pieceElement) {
                    pieceElement.classList.add('selected');
                }
            }
        }

        // Handle square click for moving pieces
        function handleSquareClick(row, col) {
            if (!selectedPiece || currentPlayer !== 'human' || gameOver || aiThinking) return;
            
            const move = validMoves.find(m => m.toRow === row && m.toCol === col);
            if (move) {
                makeMove(selectedPiece.row, selectedPiece.col, row, col, move.captured);
                selectedPiece = null;
                validMoves = [];
            }
        }

        // Get valid moves for a piece
        function getValidMoves(row, col) {
            const piece = board[row][col].piece;
            if (!piece) return [];
            
            const moves = [];
            const directions = [];
            
            if (piece.type === 'human') {
                directions.push({ dr: 1, dc: -1 });
                directions.push({ dr: 1, dc: 1 });
                
                if (piece.isKing) {
                    directions.push({ dr: -1, dc: -1 });
                    directions.push({ dr: -1, dc: 1 });
                }
            } else if (piece.type === 'ai') {
                directions.push({ dr: -1, dc: -1 });
                directions.push({ dr: -1, dc: 1 });
                
                if (piece.isKing) {
                    directions.push({ dr: 1, dc: -1 });
                    directions.push({ dr: 1, dc: 1 });
                }
            }
            
            let hasCaptures = false;
            
            for (const dir of directions) {
                const captureRow = row + dir.dr;
                const captureCol = col + dir.dc;
                const jumpRow = row + 2 * dir.dr;
                const jumpCol = col + 2 * dir.dc;
                
                if (isValidPosition(captureRow, captureCol) && isValidPosition(jumpRow, jumpCol)) {
                    const captureSquare = board[captureRow][captureCol];
                    const jumpSquare = board[jumpRow][jumpCol];
                    
                    if (captureSquare.piece && captureSquare.piece.type !== piece.type && !jumpSquare.piece) {
                        moves.push({
                            fromRow: row,
                            fromCol: col,
                            toRow: jumpRow,
                            toCol: jumpCol,
                            captured: { row: captureRow, col: captureCol },
                            isCapture: true
                        });
                        hasCaptures = true;
                    }
                }
            }
            
            if (hasCaptures) {
                return moves;
            }
            
            for (const dir of directions) {
                const newRow = row + dir.dr;
                const newCol = col + dir.dc;
                
                if (isValidPosition(newRow, newCol) && !board[newRow][newCol].piece) {
                    moves.push({
                        fromRow: row,
                        fromCol: col,
                        toRow: newRow,
                        toCol: newCol,
                        captured: null,
                        isCapture: false
                    });
                }
            }
            
            return moves;
        }

        // Check if position is valid
        function isValidPosition(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        // Make a move
        function makeMove(fromRow, fromCol, toRow, toCol, captured) {
            const piece = board[fromRow][fromCol].piece;
            if (!piece) return;
            
            saveBoardState();
            
            board[toRow][toCol].piece = {...piece, row: toRow, col: toCol};
            board[fromRow][fromCol].piece = null;
            
            if (!piece.isKing) {
                if ((piece.type === 'human' && toRow === 7) || (piece.type === 'ai' && toRow === 0)) {
                    board[toRow][toCol].piece.isKing = true;
                }
            }
            
            if (captured) {
                board[captured.row][captured.col].piece = null;
                
                if (piece.type === currentPlayer) {
                    const additionalCaptures = getValidMoves(toRow, toCol).filter(m => m.isCapture);
                    if (additionalCaptures.length > 0) {
                        if (piece.type === 'human') {
                            selectedPiece = { row: toRow, col: toCol };
                            validMoves = additionalCaptures;
                            renderBoard();
                            
                            const pieceElement = document.querySelector(`.piece[data-row="${toRow}"][data-col="${toCol}"]`);
                            if (pieceElement) {
                                pieceElement.classList.add('selected');
                            }
                            
                            updateMoveHistory(fromRow, fromCol, toRow, toCol, true, false);
                            updateGameInfo();
                            return;
                        } else if (piece.type === 'ai') {
                            let bestCapture = null;
                            let bestScore = -Infinity;
                            
                            for (const capture of additionalCaptures) {
                                const simulatedBoard = simulateMove(board, capture);
                                const score = evaluateBoard(simulatedBoard);
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestCapture = capture;
                                }
                            }
                            
                            if (bestCapture) {
                                makeMove(toRow, toCol, bestCapture.toRow, bestCapture.toCol, bestCapture.captured);
                                return;
                            }
                        }
                    }
                }
            }
            
            updateMoveHistory(fromRow, fromCol, toRow, toCol, captured !== null, false);
            
            currentPlayer = currentPlayer === 'human' ? 'ai' : 'human';
            
            checkGameOver();
            
            renderBoard();
            updateGameInfo();
            
            if (currentPlayer === 'ai' && !gameOver) {
                setTimeout(() => makeAIMove(), 500);
            }
        }

        // AI move using Minimax with Alpha-Beta Pruning
        function makeAIMove() {
            if (gameOver || currentPlayer !== 'ai') return;
            
            aiThinking = true;
            document.getElementById('game-status').textContent = 'AI o\'ylamoqda...';
            document.getElementById('game-status').className = 'bg-purple-900 p-4 rounded-lg text-center text-xl font-bold';
            
            setTimeout(() => {
                const allMoves = getAllValidMoves('ai');
                
                if (allMoves.length === 0) {
                    aiThinking = false;
                    currentPlayer = 'human';
                    checkGameOver();
                    updateGameInfo();
                    return;
                }
                
                let chosenMove;
                const depth = 6;
                let bestScore = -Infinity;
                
                for (const move of allMoves) {
                    const simulatedBoard = simulateMove(board, move);
                    const score = minimax(simulatedBoard, depth - 1, -Infinity, Infinity, false);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        chosenMove = move;
                    }
                }
                
                if (!chosenMove) {
                    const captureMoves = allMoves.filter(move => move.isCapture);
                    if (captureMoves.length > 0) {
                        chosenMove = chooseBestCapture(captureMoves);
                    } else {
                        chosenMove = chooseStrategicMove(allMoves);
                    }
                }
                
                setTimeout(() => {
                    makeMove(
                        chosenMove.fromRow, 
                        chosenMove.fromCol, 
                        chosenMove.toRow, 
                        chosenMove.toCol, 
                        chosenMove.captured
                    );
                    aiThinking = false;
                }, 200);
            }, 100);
        }
        
        // Minimax algorithm
        function minimax(boardState, depth, alpha, beta, maximizingPlayer) {
            if (depth === 0) {
                return evaluateBoard(boardState);
            }
            
            const player = maximizingPlayer ? 'ai' : 'human';
            const moves = getAllValidMovesForBoard(boardState, player);
            
            if (moves.length === 0) {
                return evaluateBoard(boardState);
            }
            
            if (maximizingPlayer) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const newBoard = simulateMove(boardState, move);
                    const eval = minimax(newBoard, depth - 1, alpha, beta, false);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const newBoard = simulateMove(boardState, move);
                    const eval = minimax(newBoard, depth - 1, alpha, beta, true);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }
        
        // Simulate move
        function simulateMove(boardState, move) {
            const newBoard = [];
            for (let row = 0; row < 8; row++) {
                newBoard[row] = [];
                for (let col = 0; col < 8; col++) {
                    const square = boardState[row][col];
                    newBoard[row][col] = {
                        row: square.row,
                        col: square.col,
                        isDark: square.isDark,
                        piece: square.piece ? {...square.piece} : null
                    };
                }
            }
            
            const piece = newBoard[move.fromRow][move.fromCol].piece;
            newBoard[move.toRow][move.toCol].piece = {...piece, row: move.toRow, col: move.toCol};
            newBoard[move.fromRow][move.fromCol].piece = null;
            
            if (move.captured) {
                newBoard[move.captured.row][move.captured.col].piece = null;
            }
            
            if (piece && !piece.isKing) {
                if ((piece.type === 'human' && move.toRow === 7) || 
                    (piece.type === 'ai' && move.toRow === 0)) {
                    newBoard[move.toRow][move.toCol].piece.isKing = true;
                }
            }
            
            return newBoard;
        }
        
        // Evaluate board (from AI perspective)
        function evaluateBoard(boardState) {
            let score = 0;
            const PIECE_VALUE = 10;
            const KING_VALUE = 30;
            const CENTER_BONUS = 0.5;
            const BACK_ROW_BONUS = 3;
            const SAFETY_BONUS = 2;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col].piece;
                    if (piece) {
                        const pieceValue = piece.isKing ? KING_VALUE : PIECE_VALUE;
                        let positionScore = 0;
                        
                        if (!piece.isKing) {
                            if (piece.type === 'ai') {
                                positionScore += (7 - row) * 0.8;
                                if (row === 0) positionScore += BACK_ROW_BONUS;
                            } else {
                                positionScore -= row * 0.8;
                                if (row === 7) positionScore -= BACK_ROW_BONUS;
                            }
                        } else {
                            const centerDist = Math.abs(row - 3.5) + Math.abs(col - 3.5);
                            positionScore += (8 - centerDist) * CENTER_BONUS;
                        }
                        
                        if (isPieceSafeInBoard(boardState, row, col, piece.type)) {
                            positionScore += SAFETY_BONUS;
                        }
                        
                        const mobility = getValidMovesForPiece(boardState, row, col).length;
                        positionScore += mobility * 0.5;
                        
                        if (piece.type === 'ai') {
                            score += pieceValue + positionScore;
                        } else {
                            score -= pieceValue + positionScore;
                        }
                    }
                }
            }
            
            return score;
        }
        
        // Helper functions (isPieceSafeInBoard, getValidMovesForPiece, getAllValidMovesForBoard, getAllValidMoves, chooseBestCapture, chooseStrategicMove, evaluateMove, isPieceSafe) 
        // — oldingi kod bilan bir xil, faqat o'zgartirish kiritilmadi

        function isPieceSafeInBoard(boardState, row, col, player) {
            const opponent = player === 'human' ? 'ai' : 'human';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = boardState[r][c].piece;
                    if (piece && piece.type === opponent) {
                        const moves = getValidMovesForPiece(boardState, r, c);
                        for (const move of moves) {
                            if (move.isCapture && move.captured.row === row && move.captured.col === col) {
                                return false;
                            }
                        }
                    }
                }
            }
            return true;
        }
        
        function getValidMovesForPiece(boardState, row, col) {
            const piece = boardState[row][col].piece;
            if (!piece) return [];
            
            const moves = [];
            const directions = [];
            
            if (piece.type === 'human') {
                directions.push({ dr: 1, dc: -1 });
                directions.push({ dr: 1, dc: 1 });
                
                if (piece.isKing) {
                    directions.push({ dr: -1, dc: -1 });
                    directions.push({ dr: -1, dc: 1 });
                }
            } else if (piece.type === 'ai') {
                directions.push({ dr: -1, dc: -1 });
                directions.push({ dr: -1, dc: 1 });
                
                if (piece.isKing) {
                    directions.push({ dr: 1, dc: -1 });
                    directions.push({ dr: 1, dc: 1 });
                }
            }
            
            let hasCaptures = false;
            
            for (const dir of directions) {
                const captureRow = row + dir.dr;
                const captureCol = col + dir.dc;
                const jumpRow = row + 2 * dir.dr;
                const jumpCol = col + 2 * dir.dc;
                
                if (isValidPosition(captureRow, captureCol) && isValidPosition(jumpRow, jumpCol)) {
                    const captureSquare = boardState[captureRow][captureCol];
                    const jumpSquare = boardState[jumpRow][jumpCol];
                    
                    if (captureSquare.piece && captureSquare.piece.type !== piece.type && !jumpSquare.piece) {
                        moves.push({
                            fromRow: row,
                            fromCol: col,
                            toRow: jumpRow,
                            toCol: jumpCol,
                            captured: { row: captureRow, col: captureCol },
                            isCapture: true
                        });
                        hasCaptures = true;
                    }
                }
            }
            
            if (hasCaptures) return moves;
            
            for (const dir of directions) {
                const newRow = row + dir.dr;
                const newCol = col + dir.dc;
                
                if (isValidPosition(newRow, newCol) && !boardState[newRow][newCol].piece) {
                    moves.push({
                        fromRow: row,
                        fromCol: col,
                        toRow: newRow,
                        toCol: newCol,
                        captured: null,
                        isCapture: false
                    });
                }
            }
            
            return moves;
        }
        
        function getAllValidMovesForBoard(boardState, player) {
            const moves = [];
            let hasCaptures = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col].piece;
                    if (piece && piece.type === player) {
                        const pieceMoves = getValidMovesForPiece(boardState, row, col);
                        const captureMoves = pieceMoves.filter(m => m.isCapture);
                        
                        if (captureMoves.length > 0) {
                            moves.push(...captureMoves);
                            hasCaptures = true;
                        }
                    }
                }
            }
            
            if (hasCaptures) return moves;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col].piece;
                    if (piece && piece.type === player) {
                        moves.push(...getValidMovesForPiece(boardState, row, col));
                    }
                }
            }
            
            return moves;
        }

        function getAllValidMoves(player) {
            const moves = [];
            let hasCaptures = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col].piece;
                    if (piece && piece.type === player) {
                        const pieceMoves = getValidMoves(row, col);
                        const captureMoves = pieceMoves.filter(m => m.isCapture);
                        
                        if (captureMoves.length > 0) {
                            moves.push(...captureMoves);
                            hasCaptures = true;
                        }
                    }
                }
            }
            
            if (hasCaptures) return moves;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col].piece;
                    if (piece && piece.type === player) {
                        moves.push(...getValidMoves(row, col));
                    }
                }
            }
            
            return moves;
        }

        function chooseBestCapture(captureMoves) {
            for (const move of captureMoves) {
                const piece = board[move.fromRow][move.fromCol].piece;
                if (!piece.isKing) {
                    if ((piece.type === 'ai' && move.toRow === 0) || 
                        (piece.type === 'human' && move.toRow === 7)) {
                        return move;
                    }
                }
            }
            
            let bestMove = captureMoves[0];
            let bestScore = -Infinity;
            
            for (const move of captureMoves) {
                const capturedPiece = board[move.captured.row][move.captured.col].piece;
                let score = capturedPiece.isKing ? 3 : 1;
                
                const piece = board[move.fromRow][move.fromCol].piece;
                if (!piece.isKing && piece.type === 'ai' && move.toRow === 0) {
                    score += 2;
                }
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            return bestMove;
        }

        function chooseStrategicMove(moves) {
            let bestMove = null;
            let bestScore = -Infinity;
            
            for (const move of moves) {
                const score = evaluateMove(move);
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            return bestMove;
        }

        function evaluateMove(move) {
            let score = 0;
            const piece = board[move.fromRow][move.fromCol].piece;
            
            if (!piece.isKing) {
                if (piece.type === 'ai') {
                    score += (move.fromRow - move.toRow) * 2;
                    if (move.toRow === 0) score += 10;
                } else {
                    score += (move.toRow - move.fromRow) * 2;
                    if (move.toRow === 7) score += 10;
                }
            } else {
                const fromCenter = Math.abs(move.fromRow - 3.5) + Math.abs(move.fromCol - 3.5);
                const toCenter = Math.abs(move.toRow - 3.5) + Math.abs(move.toCol - 3.5);
                score += (fromCenter - toCenter) * 0.5;
            }
            
            const centerDistance = Math.abs(move.toRow - 3.5) + Math.abs(move.toCol - 3.5);
            score += (8 - centerDistance) * 0.3;
            
            if (!isPieceSafe(move.toRow, move.toCol, piece.type)) {
                score -= 5;
            }
            
            const futureCaptures = getValidMoves(move.toRow, move.toCol).filter(m => m.isCapture).length;
            score += futureCaptures * 3;
            
            return score;
        }

        function isPieceSafe(row, col, player) {
            const opponent = player === 'human' ? 'ai' : 'human';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c].piece;
                    if (piece && piece.type === opponent) {
                        const moves = getValidMoves(r, c);
                        for (const move of moves) {
                            if (move.isCapture && move.captured.row === row && move.captured.col === col) {
                                return false;
                            }
                        }
                    }
                }
            }
            
            return true;
        }

        // Update move history
        function updateMoveHistory(fromRow, fromCol, toRow, toCol, isCapture, isAI) {
            const fromNotation = `${String.fromCharCode(97 + fromCol)}${8 - fromRow}`;
            const toNotation = `${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            const player = isAI ? 'AI' : 'Inson';
            const moveText = `${player}: ${fromNotation} → ${toNotation} ${isCapture ? '✗' : ''}`;
            
            moveHistory.push(moveText);
            
            const movesHistoryElement = document.getElementById('moves-history');
            if (moveHistory.length === 1) {
                movesHistoryElement.innerHTML = '';
            }
            
            const moveElement = document.createElement('div');
            moveElement.className = 'border-b border-gray-700 py-2 flex justify-between items-center';
            moveElement.innerHTML = `
                <span>${moveHistory.length}. ${moveText}</span>
                <span class="text-gray-400 text-sm">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            `;
            
            movesHistoryElement.prepend(moveElement);
            
            if (moveHistory.length > 20) {
                moveHistory.shift();
                if (movesHistoryElement.children.length > 20) {
                    movesHistoryElement.removeChild(movesHistoryElement.lastChild);
                }
            }
        }

        // Check game over
        function checkGameOver() {
            const humanMoves = getAllValidMoves('human');
            const aiMoves = getAllValidMoves('ai');
            
            let humanPieces = 0;
            let aiPieces = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col].piece;
                    if (piece) {
                        if (piece.type === 'human') humanPieces++;
                        else aiPieces++;
                    }
                }
            }
            
            document.getElementById('human-score').textContent = humanPieces;
            document.getElementById('ai-score').textContent = aiPieces;
            
            if (humanPieces === 0 || humanMoves.length === 0) {
                gameOver = true;
                document.getElementById('game-status').textContent = 'AI G\'ALABA QOZONDI!';
                document.getElementById('game-status').className = 'bg-red-900 p-4 rounded-lg text-center text-xl font-bold game-over';
                return;
            }
            
            if (aiPieces === 0 || aiMoves.length === 0) {
                gameOver = true;
                document.getElementById('game-status').textContent = 'MUMKIN EMAS! Inson g\'alaba qozondi?!';
                document.getElementById('game-status').className = 'bg-green-900 p-4 rounded-lg text-center text-xl font-bold game-over';
                return;
            }
            
            if (moveHistory.length > 100) {
                gameOver = true;
                document.getElementById('game-status').textContent = 'DURANG!';
                document.getElementById('game-status').className = 'bg-yellow-900 p-4 rounded-lg text-center text-xl font-bold game-over';
            }
        }

        // Update game info
        function updateGameInfo() {
            if (gameOver) return;
            
            const statusElement = document.getElementById('game-status');
            if (currentPlayer === 'human') {
                statusElement.textContent = 'Inson navbati';
                statusElement.className = 'bg-blue-900 p-4 rounded-lg text-center text-xl font-bold';
            } else {
                statusElement.textContent = 'AI navbati';
                statusElement.className = 'bg-purple-900 p-4 rounded-lg text-center text-xl font-bold';
            }
        }

        // Save and undo functions (unchanged)
        function saveBoardState() {
            const state = [];
            for (let row = 0; row < 8; row++) {
                state[row] = [];
                for (let col = 0; col < 8; col++) {
                    const square = board[row][col];
                    state[row][col] = {
                        row: square.row,
                        col: square.col,
                        isDark: square.isDark,
                        piece: square.piece ? {...square.piece} : null
                    };
                }
            }
            
            boardHistory.push({
                board: state,
                currentPlayer: currentPlayer,
                moveCount: moveHistory.length
            });
            
            if (boardHistory.length > 10) {
                boardHistory.shift();
            }
        }

        function undoMove() {
            if (boardHistory.length < 2 || gameOver || aiThinking) return;
            
            boardHistory.pop();
            
            const prevState = boardHistory[boardHistory.length - 1];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const squareState = prevState.board[row][col];
                    board[row][col].piece = squareState.piece ? {...squareState.piece} : null;
                }
            }
            
            currentPlayer = prevState.currentPlayer;
            
            const movesToRemove = moveHistory.length - prevState.moveCount;
            for (let i = 0; i < movesToRemove; i++) {
                moveHistory.pop();
                const movesHistoryElement = document.getElementById('moves-history');
                if (movesHistoryElement.firstChild) {
                    movesHistoryElement.removeChild(movesHistoryElement.firstChild);
                }
            }
            
            selectedPiece = null;
            validMoves = [];
            
            renderBoard();
            updateGameInfo();
            checkGameOver();
        }

        function provideHint() {
            if (currentPlayer !== 'human' || gameOver || aiThinking) return;
            
            const humanMoves = getAllValidMoves('human');
            if (humanMoves.length === 0) return;
            
            let bestMove = null;
            let bestScore = -Infinity;
            
            for (const move of humanMoves) {
                const score = evaluateMove(move);
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            if (bestMove) {
                selectedPiece = { row: bestMove.fromRow, col: bestMove.fromCol };
                validMoves = [bestMove];
                renderBoard();
                
                const pieceElement = document.querySelector(`.piece[data-row="${bestMove.fromRow}"][data-col="${bestMove.fromCol}"]`);
                if (pieceElement) {
                    pieceElement.classList.add('selected');
                }
                
                const statusElement = document.getElementById('game-status');
                statusElement.textContent = 'Maslahat: Taklif etilgan yurish belgilandi';
                statusElement.className = 'bg-yellow-900 p-4 rounded-lg text-center text-xl font-bold';
                
                setTimeout(() => {
                    if (currentPlayer === 'human' && !gameOver) {
                        selectedPiece = null;
                        validMoves = [];
                        renderBoard();
                        updateGameInfo();
                    }
                }, 3000);
            }
        }

        // Event Listeners
        document.getElementById('new-game').addEventListener('click', () => {
            selectedPiece = null;
            validMoves = [];
            currentPlayer = 'human';
            gameOver = false;
            moveHistory = [];
            boardHistory = [];
            aiThinking = false;
            
            document.getElementById('moves-history').innerHTML = 
                '<div class="text-gray-400 text-center py-4">Hozircha yurish yo\'q. Birinchi yurishni qiling!</div>';
            
            initGame();
        });

        document.getElementById('undo-move').addEventListener('click', undoMove);
        document.getElementById('hint').addEventListener('click', provideHint);

        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
